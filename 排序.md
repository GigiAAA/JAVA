衡量一个算法好坏的标准？

1.排序算法的执行效率

​	-最好、最坏、平均时间复杂度

​	-时间复杂度的系数、常数、低阶

​	-比较次数和交换次数

2.排序算法的内存消耗

​	-空间复杂度

3.稳定性

4.原地性

稳定性算法：冒泡、插入、折半、归并

非稳定算法：希尔、选择、快排

时间复杂度O(n^2)：冒泡、插入、折半、选择

时间复杂度O(nlogn)：快排、归并

#### 冒泡排序：

最坏时间复杂度：O(n^2)

最好时间复杂度：O(n)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

稳定原地

#### 插入排序：

最坏时间复杂度：O(n^2)

最好时间复杂度：O(n)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

稳定原地

冒泡排序VS插入排序

一般选择插入排序，因元素交换次数较少

#### 折半查找--直接插入优化第一种

最好时间复杂度：O(n)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n^2)

空间复杂度:O(1)

稳定原地

```html
注意：折半插入排序在数据集无序的情况下要优于直接插入排序，在近乎有序的数据集下，由于插入排序只比较一次，因此最好情况下的直接插入排序要优于折半排序。
```

#### 希尔排序

空间复杂度：O(1)

非稳定原地 

#### 选择排序

最好时间复杂度：O(n^2)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

不稳定原地  如：5 8 5 2 9

#### 归并排序

最好时间复杂度：O(nlogn)

最坏时间复杂度：O(nlogn)

平均时间复杂度：O(nlogn)

空间复杂度：O(n)

稳定非原地

#### 快速排序

最好：O(nlogn)

最坏：O(n^2)

平均：O(nlogn)

空间：O(1)

非稳定原地

#### 堆排



| 排序方法 |      平均       |   最好   |   最坏   | 空间 | 稳定性 |
| :------: | :-------------: | :------: | :------: | :--: | :----: |
|   冒泡   |     O(n^2)      |   O(n)   |  O(n^2)  | O(1) |  稳定  |
|   插入   |     O(n^2)      |   O(n)   |  O(n^2)  | O(1) |  稳定  |
|   折半   |     O(n^2)      |   O(n)   |  O(n^2)  | O(1) |  稳定  |
|   希尔   | O(nlogn)-O(n^2) | O(n^1.3) |  O(n^2)  | O(1) | 不稳定 |
|   选择   |     O(n^2)      |  O(n^2)  |  O(n^2)  | O(1) | 不稳定 |
|   归并   |    O(nlogn)     | O(nlogn) | O(nlogn) | O(n) |  稳定  |
|   快排   |    O(nlogn)     | O(nlogn) |  O(n^2)  | O(1) | 不稳定 |
|   堆排   |    O(nlogn)     | O(nlogn) | O(nlogn) | O(1) | 不稳定 |

